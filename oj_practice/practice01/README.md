# 第一次上机练习的问题

## 第1题

### 题目描述

已知一个正整数序列，个数未知，但至少有一个元素，你的任务是建立一个单链表，并使用该链表存储这个正整数序列，然后统计这个序列中元素的最大值与最小值，计算序列全部元素之和。正整数的输入用-1作为结束标志，注意-1不算这个正整数序列中的元素（不要统计-1）。

### 输入

一个正整数序列，正整数序列元素的个数未知，但以输入“-1”结束，输入“-1”前至少输入一个正整数。序列中的元素范围在1—999999999之间。

### 输出

三个正整数，即最大值、最小值、所有元素之和。

数据最多的测试用例节点数在1000这个数量级，所有整数可以用int型存储。

请注意输入输出格式。

### 评价

这道题没有任何难度。

## 第2题

### 题目描述

已知一个正整数组成的无序序列，个数未知，但至少有一个元素，你的任务是建立一个单链表，并使用该链表存储这个正整数序列，然后将这个链表进行排序，使得排序后的链表为递增序列。正整数的输入用-1作为结束标志，注意-1不算这个正整数序列中的元素（不要统计-1）。在排序的过程中，你可以自己选择排序算法（冒泡排序、选择排序等），但必须是通过修改结点的指针域来进行排序，而不是对结点的数据域进行修改。程序结束后要释放所有节点占据的空间。

### 输入

一个元素个数未知的正整数序列，以输入“-1”结束，输入“-1”前至少输入一个正整数。

### 输出

经过排序后的链表，每个元素后有一个空格，注意最后一个元素后只有换行符。

### 评价

这道题出现问题的点在于cr函数中last没有更新正确。

## 第3题

### 题目描述

已知两个由正整数组成的无序序列A、B，每个序列的元素个数未知，但至少有一个元素。你的任务是判断序列B是否是序列A的连续子序列。假设B是“1 9 2 4 18”，A是“33 64 1 9 2 4 18 7”，B是A的连续子序列；假设B是“1 9 2 4 18”，A是“33 1 9 64 2 4 18 7”，B不是A的连续子序列。

要求：建立两个单链表A、B用于存储两个正整数序列，然后按照题目的要求，判断链表B是否是链表A的连续子序列。正整数的输入用-1作为结束标志，注意-1不算这个正整数序列中的元素（不要统计-1）。在程序结束前要释放链表A、B中的所有节点。

### 输入

依次输入两个乱序的正整数序列A、B，序列中元素个数未知，但每个序列至少有一个元素，并以输入“-1”结束，每个序列占一行。注意：样例中给的是两个样例，实际的输入只有两行。

### 输出

如果序列B是序列A的连续子序列，则输出“ListB is the sub sequence of ListA.”，否则输出“ListB s not the sub sequence of ListA.”。

### 评价

本题问题出在issub函数中的第二个嵌套循环条件，倘若没有 tmp!=NULL，以下输入可能会导致错误。

```
1 2 3 6 5 4 -1
6 5 4 3 2 -1
```

## 第4题

### 题目描述

已知一个正整数序列，序列元素个数未知，但至少有两个元素，你的任务是建立一个单链表用于存储这个正整数序列。然后实现交换此链表中任意指定的两段，第一段为[s1,t1]，第二段[s2,t2]。s1、t1、s2、t2代表链表的第几个节点，且满足s1<=t1，s2<=t2，t1<s2，s2一定小于等于链表节点的总个数。正整数的输入用-1作为结束标志，注意-1不算这个正整数序列中的元素（不要统计-1）。最后将链表的全部节点释放。

### 输入

输入一个正整数序列，以输入“-1”结束，序列中元素个数未知，但输入“-1”前至少输入两个正整数。然后是四个整数，即为s1、t1、s2、t2。

### 输出

经过处理后的新链表，每个元素后有一个空格，注意最后一个元素后只有换行符。

### 评价

本题的问题在于要将t1=s2-1的情况进行单独讨论，因为此时可能会导致死循环。

## 第5题

### 题目描述

已知有两个递增的正整数序列A和B，序列中元素个数未知，同一序列中不会有重复元素出现，有可能某个序列为空。现要求将序列B归并到序列A中，且归并后序列A的数据仍然按递增顺序排列。如果序列B中某些数据在序列A中也存在，则这些数据所在节点仍然留在序列B中，而不被归并到序列A中；否则这些数据所在节点将从序列B中删除，添加到序列A中。

要求：建立两个单链表A、B用于存储两个正整数序列，然后按照题目的要求，将链表B中的元素归并到链表A中。在归并的过程中，不要释放B中的节点空间、然后建立新节点，而要改变指针的指向，使元素从B中删除并添加到A中。正整数序列按照递增顺序输入，用-1作为结束标志，注意-1不算这个正整数序列中的元素（不要统计-1）。在程序结束前要释放链表A、B中的所有节点。

### 输入

依次输入两个递增的正整数序列A和B，序列元素的个数未知，但以输入“-1”结束，每个正整数序列占一行。

### 输出

处理后的链表A中的元素，占一行；然后是处理后的链表B中的元素，占一行。每行的每个元素后有一个空格，注意最后一个元素后只有换行符，如果某个链表为空则，则输出“There is no item in X list.”

### 评价

本题的问题主要在于如果A是一个空链表且B不是一个空链表，就要将B全部复制给A再输出。但是此时可能出现Segmentation Fault。于是我们仅仅将B以A的名字输出，并不执行merge函数，就不会出现Segmentation Fault了。

| A    | B    | 结果               |
| ---- | ---- | ------------------ |
| NULL | NULL | merge函数正常      |
| NULL | 非空 | Segmentation Fault |
| 非空 | NULL | merge函数正常      |
| 非空 | 非空 | merge函数正常      |

## 第6题

### 题目描述

已知有一个乱序的字符序列L，序列中的字符可能是英文字母、数字字符或其它字符，字符的个数未知，每个字符之间用空格分开。字符序列用“-1”作为输入结束标志，这里你要把-1当做一个字符串对待，并且不算作字符序列中的元素。如下即为一个合法的字符序列：“a c 3 b a d 6 , & j m 8 7 2 V -1”。你的任务是将这个字符序列拆分为三个独立的序列A、B和C，其中序列A存放序列L中的字母，序列B存放序列L中的数字，序列C存放序列L中的其他字符，然后，将序列A、B和C分别按照ASCII码的大小关系进行升序排序。最终序列L将变为空序列。

要求：建立四个单链表，分别存储序列L、A、B、C中的元素。字符序列的输入用“-1”作为结束标志。建立链表L时，建议使用scanf(“%s”,s);来读取字符序列中的字符，即把单独的字符看做一个字符串读取。当L建立后，你要按照问题描述中所述，将L拆分为A、B、C三个链表，然后对每个链表都进行排序，这部分的操作都应该是对指针进行修改，而不是删除节点与建立新节点。在程序结束前要释放链表A、B、C中的所有节点。

### 输入

一个乱序的字符序列，序列元素的个数未知，以输入“-1”结束，输入“-1”前可能没有其它元素，每个字符序列占一行。

### 输出

链表A中的元素，占一行；然后是链表B中的元素，占一行。最后是链表C中的元素，占一行。每行的每个元素后有一个空格，注意最后一个元素后只有换行符，如果某个链表为空则，则输出“There is no item in X list.”

### 评价

本题没有什么难度，唯一可能出错的就是在merge函数之中对于tmp的设置，只要不出现Segmentation Fault即可。
